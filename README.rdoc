The purpose of this gem is to have a standard way of configuring objects that is useable by other Ruby gems.

== Features

There are plenty of other gems that provide a configuration facility. This exists to provide a unique set of special features.

* Support for complex configuration object that can contain their own logic
* Support for multiple configuration objects of the same class
* Support for different settings for different environments
* Configuration can be done from Ruby code or YAML files
* DRY up your configuration with defaults
* Configured values are frozen so they can't be accidentally modified
* Configuration can be reloaded at any time and notify observing objects

== Examples

For the examples, we'll suppose we have some city data which is pretty static and doesn't change much.

To use this library, we just need to declare a class that includes ConfigObject. Including this module will add an +id+ attribute and an +initialize+ method that sets attributes based on a hash. For each key in the hash, the initializer will look for a setter method and call it with the value. If there is no setter method, it will simply set an instance variable with the same name.

  class City
    include ConfigObject
    attr_reader :name, :county, :state, :population, :census_year, :hostname
    
    # Set the county information based on a hash. This feature can be used to create
    # complex objects from simple configuration hashes.
    def county= (attributes)
      if attributes
        @county = County.new(attributes)
      else
        @county = nil
      end
    end
    
    # We can use the objects as more than simple data stores because we can add whatever
    # logic we like to the class
    def size
      if population > 1000000
        :big
      elsif population > 300000
        :medium
      else
        :small
      end
    end
  end
  
  # The initializer behavior of setting attributes based on a hash is available in the module Attributes,
  # so if we just want that behavior, we can include it in any module.
  class County
    include ConfigObject::Attributes
    attr_reader :name, :population
  end

You can use a YAML file to load multiple cities like so:

  chicago:
    name: Chicago
    state: IL
    population: 3000000
    census_year: 2008
    county:
      name: Cook
      population: 5000000
  
  st_louis:
    name: St. Louis
    state: MO
    population: 1000000
    census_year: 2000
    county:
      name: 
      population: 

  milwaukee:
    name: Milwaukee
    state: WI
    population: 1000000
    census_year: 2000
    county:
      name: Milwaukee
      population: 

This will give us three cities with ids of "chicago", "st_louis", and "milwaukee". If we want to reference them, we can call

  City[:chicago]

or

  City['chicago']

If we want all of them, we can call

  City.all

If we want to find by something other than the id, we can also do that with a filter hash. The keys to the hash will be attributes to call and compare to values. You can go deep into the objects by delimiting attributes with a dot. If the attributes takes a single argument, it will be called with the match value, otherwise it will be compared to the match value. The match value can be a regular expression.

  City.find(:name => "Chicago")            # Chicago
  City.find(:name => /^St/)                # St. Louis
  City.find("county.name" => 'Milwaukee')  # Milwaukee
  City.all("county.population.>", 2000000) # Chicago and St. Louis

The result of finding by a hash are cached for future lookups so their is no performance penalty for calling them multiple times.

== Configuring

As show above, you can configure a class with a YAML file. You can also specify multiple YAML files, a directory containing YAML files, or specify your configuration from Ruby code.

[One YAML file]
<tt>City.configuration_files = 'config/cities.yml'</tt>

[Multiple YAML files]
<tt>City.configuration_files = 'config/cities.yml', 'config/production_cities.yml'</tt>

[Configure from code]
  City.configure({
    :chicago => {:name => "Chicago", :population => 3000000},
    :st_louis => {:name => "St. Louis", :population => 1000000}
  })

== Default Values

If you have some attributes that are mostly the same across all configuration objects, you can specify default values to DRY up you configuration. For instance in our city sample, we could specify a default census year and then only have to override the values for Chicago.

  defaults:
    census_year: 2000
  
  chicago:
    census_year: 2008

Defaults can only be specified for root level hash. You can also specify defaults with the +set_defaults+ method.

== Stable Values

The attributes set on the configuration objects will be automatically frozen. This is to protect you from accidentally calling destructive methods on them (ie. << or gsub! on String) and changing the original values. These sorts of bugs can be awfully hard to find especially in a Rails application where they may only appear when the code gets to production.

== Reloading

You can reload the configuration objects at any time with the +reload+ method. In addition, object can register themselves with the configuration class using +add_observer+ and specifying a callback. The callback method or block will be called whenever the configuration is changed so that persistent objects that use the configuration can reinitialize themselves with the new values.